from fastapi import APIRouter, HTTPException
from fastapi.responses import Response
import typst
from pydantic import BaseModel
from typing import List, Dict, Any, Optional
import structlog
import os
import tempfile

logger = structlog.get_logger(__name__)
router = APIRouter()

class ChatMessage(BaseModel):
    role: str
    content: str
    timestamp: Optional[str] = None

class AnalysisDataRow(BaseModel):
    # Dynamic dictionary for table rows
    pass

class ExportRequest(BaseModel):
    title: str = "Analysis Report"
    messages: List[ChatMessage] = []
    analysis_data: Optional[List[Dict[str, Any]]] = None
    metrics: Optional[Dict[str, Any]] = None

def generate_typst_content(request: ExportRequest) -> str:
    """Generate Typst document content from the request data."""
    
    # Base template with styling
    content = [
        # Setup document properties
        f'#set document(title: "{request.title}")',
        '#set page(paper: "a4", margin: (x: 2cm, y: 2.5cm))',
        '#set text(font: ("Sarabun", "TH Sarabun New", "Noto Sans Thai", "Arial"), size: 11pt)',
        
        # Title
        f'#align(center)[#text(size: 24pt, weight: "bold")[{request.title}]]',
        '#v(1em)',
        
        # Date
        '#align(right)[_Generated by AI Analyst_]',
        '#v(2em)',
    ]

    # Metrics Section
    if request.metrics:
        content.append('#heading(level: 1)[Metrics Summary]')
        content.append('#v(0.5em)')
        for key, value in request.metrics.items():
            content.append(f'- **{key}**: {value}')
        content.append('#v(1.5em)')

    # Analysis Data Table Section
    if request.analysis_data and len(request.analysis_data) > 0:
        content.append('#heading(level: 1)[Analysis Data]')
        content.append('#v(0.5em)')
        
        headers = list(request.analysis_data[0].keys())
        
        # Format table header
        table_cols = len(headers)
        col_sizes = ", ".join(["auto"] * table_cols)
        
        content.append(f'#table(columns: ({col_sizes}),')
        content.append('  align: center,')
        
        # Add headers
        for h in headers:
            content.append(f'  [*{" ".join(h.split("_")).title()}*],')
            
        # Add rows (max 50 rows to keep PDF reasonable)
        for row in request.analysis_data[:50]:
            for h in headers:
                val = str(row.get(h, ""))
                # Escape special typst characters
                val = val.replace("#", "\\#").replace("$", "\\$")
                content.append(f'  [{val}],')
        
        content.append(')')
        
        if len(request.analysis_data) > 50:
            content.append(f'#text(style: "italic", size: 9pt)[Showing 50 of {len(request.analysis_data)} rows]')
            
        content.append('#v(1.5em)')

    # Chat History Section
    if request.messages:
        content.append('#heading(level: 1)[Chat History]')
        content.append('#v(0.5em)')
        
        for msg in request.messages:
            role_display = "User" if msg.role == "user" else "AI Analyst"
            # Escape Typst special characters in content
            safe_content = msg.content.replace("#", "\\#").replace("$", "\\$")
            
            # Simple markdown-like to Typst conversion for basic formatting
            # This is very basic, a robust solution would use a proper parser
            
            content.append(f'**{role_display}**:')
            content.append(f'{safe_content}')
            content.append('#v(1em)')

    return "\n".join(content)

@router.post("/pdf")
async def export_pdf(request: ExportRequest):
    """Generate and return a PDF from chat and analysis data."""
    try:
        typst_content = generate_typst_content(request)
        
        # We need to compile the Typst string.
        # typst.compile(text) works in newer versions of typst-py
        try:
            pdf_bytes = typst.compile(typst_content)
        except Exception as e:
            logger.error(f"Failed to compile Typst content directly: {e}")
            # Fallback for some versions: compile from file
            with tempfile.NamedTemporaryFile(suffix=".typ", mode="w", delete=False) as f:
                f.write(typst_content)
                temp_path = f.name
                
            try:
                pdf_bytes = typst.compile(temp_path)
            finally:
                if os.path.exists(temp_path):
                    os.unlink(temp_path)
        
        return Response(
            content=pdf_bytes,
            media_type="application/pdf",
            headers={
                "Content-Disposition": "attachment; filename=analysis_export.pdf"
            }
        )
    except Exception as e:
        logger.error(f"PDF export failed: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to generate PDF: {str(e)}")
